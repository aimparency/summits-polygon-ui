#2022-07-01
Ok, welche features wären mir denn jetzt noch am wichtigsten? 
- pinnen (Local storage array der ids)
- blacklisten (nervige aims blacklisten können) 
- share aims by link (contains the aim addr) 
- load connections and recoursively load aims (until a certain distance) 
  - gestrichelter stroke, wenn die connections eines aims noch nicht geladen werden 
    loadLevel = 0 oder so
- aim erstellen in einer Transaktion (mit allen werten) 
  - key-value pairs
  - analoges interface für flow creations
    - dx, dy als float32 als "position" key-value pair
    - description als string 
- aims über the graph suchen können

#2022-06-30
- key-value store

#2022-06-28
- also doch vielleicht key value store. (wegen solidity's 16 local var limit, string size = 2 slots)
  - um bequem mit einem Aufruf mehrere felder setzen zu können

#2022-06-27
- Create Flows onchain
- Permissions on aimparency fixen
- Fix bug: token mint on aim creation seems to be broken

#2022-06-24
- Nodes and Flows you create on chain get pinned automatically
- Maybe
  - Nodes and Flows you create locally get stored in an indexedDB
  - But maybe skip indexedDB and use matrix right away

#2022-06-23
- createOnChain für beides
- commit changes nur für die felder
- buy und sell für token changes

#2022-06-22
- Now that smart contracts work
  - reset "origin" on createOnChain
  - implement change aims

- connections
  - when loading: buffer until absent aim gets loaded. 
  - Edit baseAim and automatically load 

- Info LED for aims and flows
  - red: changes
  - blue: same as on chain

- Local storage 
  - store aim addresses locally and load them, when opening the tab again
    - or maybe allow to "pin" aims, that get loaded automatically
    - and allow to "blacklist" annoying aims (e.g. wide titles) 

- The Graph natürlich (endlich, hat mal wieder länger gedauert ^^) 


#2022-06-14
- Effort in engery umbenennen?
  - Was ist eine gute Metrik? Gibt es da überhaupt eine Dimension?
  - Energy... aber z.B. für computation hängt energy davon ab, wie gut die chips sind
    - schwer zu bemessen
    - vielleicht lasse ich es einfach weg? effort?
    - Zeit mag ich nicht, weil es keinen Sinn ergibt, Sachen in Zeit zu messen. 

- Ok, also, ich würde gern... voranschreiten
  - aims speichern on chain
  - aims ändern on chain
  - dann: subgraph schreiben
  - dauert alles länger als gedacht. Ist aber so. 

- Layout
  - vieleicht wäre es gut, wenn es so einen Toleranzbereich gibt, in dem sich nichts verschiebt
  - Aber eh will ich die dx und dy aus den flows verwenden. 

- Flows
  - man soll es sehen, wenn riesenpfeile ... von kleinen Aims abgehen 
  - oder doch: zu kleinen Aims zeigen? flows...
  - "depends on" vs. "contributes to"
  - contributes to ist schöner. Zukunft, in Richtung
  - kann die Pfeile ja so ändern, dass ich am Ende einen Kreis male "round cap" <<== DAS!
  - daran erkennt man dann auch ganz schön: so groß müsste das Ziel eigentlich sein!
  - größe bemisst sich an into-aim

- Bug fixen
  - nach langer laufzeit ruckelt es
  - liegt an stack grow bei "layout" funktion. 

- Performance optimization (layout) 
  - reuse arrays (except boxes) by accessing indizes instead of push
  - or maybe even better: try directly (leaving out vue) modifying the svg props. 

- D: removing connections when removing aims
- "..." anzeigen, wenn ein aim noch keinen Namen hat

# umgekehrt chronologisch

- D(musste get element under point - hack benutzen): connect on touch release

- D: aim layout: die selected Node nicht bewegen :) 

- D: aims connecten / flows anzeigen

- "public" optional machen (hardcode true von mir aus bis zum ico)
  - nur wenn public auf blockchain veröffentlichen 

- Datamodel
  - connections sind selbstständige objekte
  - goals haben eingänge und ausgänge
  - connections gehören zum benefitting aim
    - werden also auf der chain veröffentlicht, wenn das receiving aim öffentlich ist

- von gl-vec2 wegwechseln, um mehr precision als Float32 zu haben
  - vielleicht ne eigene kleine lib bauen
    - add, sub, divN, multN
    - alles inplace + returning 
    - clone
    - operating on {x: number, y: number} 
